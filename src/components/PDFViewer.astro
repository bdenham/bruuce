---
interface Props {
  src: string;
  width?: string;
  height?: string;
  scale?: number;
  page?: number;
  caption?: string;
}

const { src, width = '100%', height = 'auto', scale = 1.0, page = 1, caption } = Astro.props;
const pdfPath = src.startsWith('http') ? src : `/${src.replace(/^\/+/, '')}`;
const workerId = `pdf-${Math.random().toString(36).substr(2, 9)}`;
const figureId = `pdf-figure-${Math.random().toString(36).substr(2, 9)}`;
const captionId = caption ? `pdf-caption-${Math.random().toString(36).substr(2, 9)}` : undefined;
---

<figure class="pdf-figure" id={figureId}>
  <div
    class="pdf-container"
    style={`width: ${width}; ${height !== 'auto' ? `height: ${height};` : ''}`}
  >
    <pdf-viewer
      data-pdf-path={pdfPath}
      data-worker-path="https://unpkg.com/pdfjs-dist@4.0.269/build/pdf.worker.min.mjs"
      data-scale={scale}
      data-page={page}
      data-maintain-aspect={height === '100%' ? 'true' : 'false'}
      aria-describedby={captionId}
      role="img"
      aria-label={caption || 'PDF document'}
      id={workerId}
    >
      <div class="loading">üìÑ Loading PDF...</div>
    </pdf-viewer>
    {
      caption && (
        <div class="pdf-caption" id={captionId}>
          {caption}
        </div>
      )
    }
  </div>
</figure>

<!-- PDF.js now loaded dynamically for better performance -->

<script>
  class PDFViewer extends HTMLElement {
    pdfDoc: any = null;
    currentModal: HTMLElement | null = null;
    originalRect: DOMRect | null = null;
    originalCenterX: number | null = null;
    originalCenterY: number | null = null;

    connectedCallback() {
      // Use Intersection Observer for lazy loading PDF
      this.setupLazyLoading();
    }

    setupLazyLoading() {
      if (typeof IntersectionObserver !== 'undefined') {
        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                this.loadPDF();
                observer.disconnect();
              }
            });
          },
          {
            rootMargin: '200px', // Load when 200px away from viewport
            threshold: 0.1,
          }
        );

        observer.observe(this);
      } else {
        // Fallback - load immediately
        this.loadPDF();
      }
    }

    async loadPDF() {
      try {
        const path = this.getAttribute('data-pdf-path');
        const workerPath = this.getAttribute('data-worker-path');

        if (!path || !workerPath) {
          console.error('Missing required PDF attributes');
          return;
        }
        const scale = parseFloat(this.getAttribute('data-scale') || '1.0');
        const pageNumber = parseInt(this.getAttribute('data-page') || '1');
        const maintainAspect = this.getAttribute('data-maintain-aspect') === 'true';

        // Dynamically load PDF.js for better performance
        if (!(window as any).pdfjsLib) {
          try {
            await this.loadPDFLibrary();
          } catch (error) {
            console.error('Failed to load PDF.js library:', error);
            this.showError('Failed to load PDF library');
            return;
          }
        }

        (window as any).pdfjsLib.GlobalWorkerOptions.workerSrc = workerPath;

        const loadingTask = (window as any).pdfjsLib.getDocument(path);
        this.pdfDoc = await loadingTask.promise;

        const page = await this.pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale });

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        if (!context) {
          console.error('Could not get canvas context');
          return;
        }

        if (maintainAspect) {
          const containerWidth = this.offsetWidth;
          const containerHeight = this.offsetHeight;

          const scaleToFit = Math.min(
            containerWidth / viewport.width,
            containerHeight / viewport.height
          );

          const scaledViewport = page.getViewport({ scale: scaleToFit });
          canvas.width = scaledViewport.width;
          canvas.height = scaledViewport.height;

          const renderContext = {
            canvasContext: context,
            viewport: scaledViewport,
          };

          await page.render(renderContext).promise;
        } else {
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          const renderContext = {
            canvasContext: context,
            viewport: viewport,
          };

          await page.render(renderContext).promise;
        }

        canvas.style.cssText = `
          width: 100%;
          height: auto;
          cursor: zoom-in;
          border-radius: 4px;
          transition: transform 0.2s ease;
        `;

        canvas.addEventListener('mouseenter', () => {
          canvas.style.transform = 'scale(1.02)';
        });

        canvas.addEventListener('mouseleave', () => {
          canvas.style.transform = 'scale(1)';
        });

        canvas.addEventListener('click', () => {
          this.openModal(canvas, page);
        });

        if (this.innerHTML) {
          this.innerHTML = '';
        }
        this.appendChild(canvas);
      } catch (error) {
        console.error('Error loading PDF:', error);
        if (this.innerHTML) {
          this.innerHTML = '<div class="error">‚ùå Error loading PDF</div>';
        }
      }
    }

    openModal(originalCanvas: HTMLCanvasElement, page: any) {
      if (this.currentModal) return;

      const rect = originalCanvas.getBoundingClientRect();
      this.originalRect = rect;
      this.originalCenterX = rect.left + rect.width / 2;
      this.originalCenterY = rect.top + rect.height / 2;

      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const maxModalWidth = viewportWidth * 0.9;
      const maxModalHeight = viewportHeight * 0.9;

      const aspectRatio = rect.width / rect.height;

      let modalWidth: number;
      if (maxModalWidth / aspectRatio <= maxModalHeight) {
        modalWidth = maxModalWidth;
      } else {
        modalWidth = maxModalHeight * aspectRatio;
      }

      const modalScale = modalWidth / rect.width;
      const modalBaseViewport = page.getViewport({ scale: modalScale });

      const finalCenterX = viewportWidth / 2;
      const finalCenterY = viewportHeight / 2;

      const modal = document.createElement('div') as HTMLDivElement;
      modal.setAttribute('role', 'dialog');
      modal.setAttribute('aria-modal', 'true');
      modal.setAttribute('aria-labelledby', 'pdf-modal-title');
      modal.setAttribute('aria-describedby', 'pdf-modal-desc');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        cursor: zoom-out;
        transition: background-color 0.25s ease;
      `;

      const modalContent = document.createElement('div') as HTMLDivElement;
      modalContent.style.cssText = `
        position: absolute;
        width: ${rect.width}px;
        height: ${rect.height}px;
        left: ${this.originalCenterX - rect.width / 2}px;
        top: ${this.originalCenterY - rect.height / 2}px;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 2px 8px var(--shadow-secondary);
        transform-origin: center center;
        transition: all 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        overflow: hidden;
        /* backdrop-filter: blur(8px); */ /* Disabled for performance */
      `;

      // Add screen reader titles
      const modalTitle = document.createElement('h2');
      modalTitle.id = 'pdf-modal-title';
      modalTitle.className = 'sr-only';
      modalTitle.textContent = 'PDF Viewer';

      const modalDesc = document.createElement('p');
      modalDesc.id = 'pdf-modal-desc';
      modalDesc.className = 'sr-only';
      modalDesc.textContent = 'Press Escape or click the X to close this dialog';

      const closeButton = document.createElement('button') as HTMLButtonElement;
      closeButton.setAttribute('aria-label', 'Close PDF viewer dialog');
      closeButton.style.cssText = `
        position: fixed;
        top: 2rem;
        right: 2rem;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: var(--bg-card);
        border: 2px solid var(--border-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: bold;
        line-height: 1;
        text-align: center;
        color: var(--text-primary);
        box-shadow: 0 4px 12px var(--shadow-primary);
        transition: all 0.2s ease;
        z-index: 10001;
        opacity: 0;
        transform: scale(0.8);
      `;
      closeButton.innerHTML = '√ó';
      closeButton.addEventListener('click', (e) => {
        e.stopPropagation();
        this.closeModal();
      });

      closeButton.addEventListener('mouseenter', () => {
        closeButton.style.background = 'var(--bg-card-hover)';
        closeButton.style.transform = 'scale(1.1)';
      });

      closeButton.addEventListener('mouseleave', () => {
        closeButton.style.background = 'var(--bg-card)';
        closeButton.style.transform = 'scale(1)';
      });

      const modalCanvas = document.createElement('canvas') as HTMLCanvasElement;
      const modalContext = modalCanvas.getContext('2d');
      if (!modalContext) {
        console.error('Could not get modal canvas context');
        return;
      }

      modalCanvas.width = modalBaseViewport.width;
      modalCanvas.height = modalBaseViewport.height;
      modalCanvas.style.cssText = `
        width: ${rect.width - 32}px;
        height: ${rect.height - 32}px;
        border-radius: 4px;
        transition: all 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      `;

      const modalRenderContext = {
        canvasContext: modalContext,
        viewport: modalBaseViewport,
      };

      page.render(modalRenderContext);

      modalContent.appendChild(modalCanvas);
      modal.appendChild(modalTitle);
      modal.appendChild(modalDesc);
      modal.appendChild(modalContent);
      modal.appendChild(closeButton);
      document.body.appendChild(modal);

      // Focus management
      setTimeout(() => closeButton.focus(), 100);

      // Trap focus within modal
      modal.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeModal();
        }
        if (e.key === 'Tab') {
          // Only close button is focusable, so just keep focus on it
          e.preventDefault();
          closeButton.focus();
        }
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeModal();
        }
      });

      this.currentModal = modal;

      requestAnimationFrame(() => {
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';

        modalContent.style.width = `${modalBaseViewport.width + 32}px`;
        modalContent.style.height = `${modalBaseViewport.height + 32}px`;
        modalContent.style.left = `${finalCenterX - (modalBaseViewport.width + 32) / 2}px`;
        modalContent.style.top = `${finalCenterY - (modalBaseViewport.height + 32) / 2}px`;
        modalContent.style.boxShadow = '0 10px 30px var(--shadow-primary)';

        modalCanvas.style.width = `${modalBaseViewport.width}px`;
        modalCanvas.style.height = `${modalBaseViewport.height}px`;

        setTimeout(() => {
          closeButton.style.opacity = '1';
          closeButton.style.transform = 'scale(1)';
        }, 150);
      });
    }

    async loadPDFLibrary() {
      // Create a script element to load PDF.js dynamically
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/pdfjs-dist@4.0.269/build/pdf.min.mjs';
        script.type = 'module';
        script.onload = () => {
          // Give PDF.js a moment to initialize
          setTimeout(resolve, 100);
        };
        script.onerror = () => reject(new Error('Failed to load PDF.js'));
        document.head.appendChild(script);
      });
    }

    showError(message: string) {
      this.innerHTML = `
        <div class="pdf-error" style="
          padding: 20px;
          text-align: center;
          color: var(--text-tertiary);
          background: var(--bg-secondary);
          border-radius: 8px;
          border: 1px solid var(--border-secondary);
        ">
          <div style="font-size: 24px; margin-bottom: 8px;">üìÑ</div>
          <p style="margin: 0; font-size: 14px;">${message}</p>
        </div>
      `;
    }

    closeModal() {
      if (
        this.currentModal &&
        this.originalRect &&
        this.originalCenterX !== null &&
        this.originalCenterY !== null
      ) {
        const modal = this.currentModal;
        const modalContent = modal.querySelector('div') as HTMLElement;
        const modalCanvas = modal.querySelector('canvas') as HTMLCanvasElement;
        const closeButton = modal.children[1] as HTMLElement;

        if (closeButton) {
          closeButton.style.opacity = '0';
          closeButton.style.transform = 'scale(0.8)';
        }

        modal.style.backgroundColor = 'rgba(0, 0, 0, 0)';

        if (
          modalContent &&
          modalCanvas &&
          this.originalRect &&
          this.originalCenterX !== null &&
          this.originalCenterY !== null
        ) {
          modalContent.style.width = `${this.originalRect.width}px`;
          modalContent.style.height = `${this.originalRect.height}px`;
          modalContent.style.left = `${this.originalCenterX - this.originalRect.width / 2}px`;
          modalContent.style.top = `${this.originalCenterY - this.originalRect.height / 2}px`;
          modalContent.style.boxShadow = '0 2px 8px var(--shadow-secondary)';

          modalCanvas.style.width = `${this.originalRect.width - 32}px`;
          modalCanvas.style.height = `${this.originalRect.height - 32}px`;
        }

        setTimeout(() => {
          if (modal && modal.parentNode) {
            document.body.removeChild(modal);
          }
        }, 250);

        this.currentModal = null;
        this.originalRect = null;
        this.originalCenterX = null;
        this.originalCenterY = null;
      }
    }
  }

  if (!customElements.get('pdf-viewer')) {
    customElements.define('pdf-viewer', PDFViewer);
  }
</script>

<style>
  .pdf-figure {
    margin: 2rem 0;
    padding: 0;
    width: fit-content;
    max-width: 100%;
  }

  .pdf-container {
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    padding: 1rem;
    background: var(--bg-card);
    width: fit-content;
    max-width: 100%;
    transition: all 0.2s ease;
  }

  .pdf-container:hover {
    border-color: var(--border-primary);
    box-shadow: 0 4px 12px var(--shadow-secondary);
  }

  .pdf-caption {
    margin-top: 0.75rem;
    padding: 0;
    font-size: 0.875rem;
    line-height: 1.5;
    color: var(--text-muted);
    text-align: left;
    font-style: italic;
    max-width: 100%;
    word-wrap: break-word;
  }

  .loading {
    text-align: center;
    padding: 2rem;
    color: var(--text-muted);
    font-size: 1.1rem;
  }

  .error {
    text-align: center;
    padding: 2rem;
    color: var(--text-muted);
    font-size: 1.1rem;
    background: var(--bg-card);
    border: 1px solid var(--border-secondary);
    border-radius: 8px;
    border-left: 4px solid #ef4444;
  }
</style>
